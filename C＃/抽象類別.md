

在 C# 中，抽象類別 (Abstract Class) 是一種特殊的類別，它不能被直接實例化，主要用於提供一個基底藍圖，讓其子類別繼承並實作其中的抽象成員。抽象類別可以包含抽象成員 (沒有實作的方法、屬性、事件或索引器) 和具體成員 (有實作的成員)。

## 特性

- **不能直接實例化**：您不能使用 `new` 關鍵字直接創建抽象類別的實例。
- **包含抽象成員**：抽象類別可以包含一個或多個抽象方法 (或其他抽象成員)。抽象方法沒有方法體，只有宣告。
- **包含具體成員**：抽象類別也可以包含普通的 (非抽象的) 方法、欄位、屬性、建構函式等。
- **必須被繼承**：抽象類別的目的是作為基底類別，被其他具體類別繼承。
- **子類別必須實作抽象成員**：如果一個非抽象子類別繼承了抽象類別，它必須實作基底抽象類別中的所有抽象成員，除非子類別本身也是抽象類別。

## 語法

使用 `abstract` 關鍵字來宣告抽象類別和抽象成員。

```csharp
public abstract class Shape
{
    public abstract double GetArea(); // 抽象方法，沒有實作

    public void Display() // 具體方法
    {
        Console.WriteLine("這是一個形狀。");
    }
}

public class Circle : Shape
{
    public double Radius { get; set; }

    public Circle(double radius)
    {
        Radius = radius;
    }

    // 必須實作抽象基底類別的 GetArea 方法
    public override double GetArea()
    {
        return Math.PI * Radius * Radius;
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        // Shape s = new Shape(); // 錯誤：不能實例化抽象類別
        Circle circle = new Circle(5);
        Console.WriteLine($"圓的面積: {circle.GetArea()}");
        circle.Display();
    }
}
```

## 使用時機

- 當您希望定義一個通用介面，但同時也想提供一些共同的預設行為或狀態時。
- 當您希望強制子類別實作某些特定的行為時。
- 當您的設計中存在「is-a」關係 (繼承) 時。

## 相關概念

- [[interface]]
- [[Inheritance]]
- [[多型]]
- [[抽象化]]

#tags: #OOP #AbstractClass #型別
